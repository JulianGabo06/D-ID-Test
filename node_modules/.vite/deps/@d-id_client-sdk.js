// node_modules/@d-id/client-sdk/dist/index.js
var G = ((e) => (e.TRIAL = "trial", e.BASIC = "basic", e.ENTERPRISE = "enterprise", e.LITE = "lite", e.ADVANCED = "advanced", e))(G || {});
var ee = ((e) => (e.TRIAL = "deid-trial", e.PRO = "deid-pro", e.ENTERPRISE = "deid-enterprise", e.LITE = "deid-lite", e.ADVANCED = "deid-advanced", e.BUILD = "deid-api-build", e.LAUNCH = "deid-api-launch", e.SCALE = "deid-api-scale", e))(ee || {});
var te = ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(te || {});
var _ = ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e.Playground = "Playground", e.DirectPlayback = "DirectPlayback", e))(_ || {});
var b = ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Complete = "done", e))(b || {});
var ne = ((e) => (e.KnowledgeProcessing = "knowledge/processing", e.KnowledgeIndexing = "knowledge/indexing", e.KnowledgeFailed = "knowledge/error", e.KnowledgeDone = "knowledge/done", e))(ne || {});
var re = ((e) => (e.Knowledge = "knowledge", e.Document = "document", e.Record = "record", e))(re || {});
var ae = ((e) => (e.Pdf = "pdf", e.Text = "text", e.Html = "html", e.Word = "word", e.Json = "json", e.Markdown = "markdown", e.Csv = "csv", e.Excel = "excel", e.Powerpoint = "powerpoint", e.Archive = "archive", e.Image = "image", e.Audio = "audio", e.Video = "video", e))(ae || {});
var L = ((e) => (e.Clip = "clip", e.Talk = "talk", e))(L || {});
var x = ((e) => (e.Start = "START", e.Stop = "STOP", e))(x || {});
var U = ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e.StreamFailed = "stream/error", e.StreamReady = "stream/ready", e.StreamCreated = "stream/created", e.StreamVideoCreated = "stream-video/started", e.StreamVideoDone = "stream-video/done", e.StreamVideoError = "stream-video/error", e.StreamVideoRejected = "stream-video/rejected", e))(U || {});
var y = ((e) => (e.New = "new", e.Fail = "fail", e.Connected = "connected", e.Connecting = "connecting", e.Closed = "closed", e.Completed = "completed", e.Disconnected = "disconnected", e))(y || {});
var ie = ((e) => (e.Amazon = "amazon", e.Microsoft = "microsoft", e.Afflorithmics = "afflorithmics", e.Elevenlabs = "elevenlabs", e))(ie || {});
var se = ((e) => (e.Public = "public", e.Premium = "premium", e.Private = "private", e))(se || {});
var z = "https://api.d-id.com";
var oe = "wss://notifications.d-id.com";
var ce = "79f81a83a67430be2bc0fd61042b8faa";
var F = () => Math.random().toString(16).slice(2);
function J() {
  let e = window.localStorage.getItem("did_external_key_id");
  return e || (e = Math.random().toString(16).slice(2), window.localStorage.setItem("did_external_key_id", e)), e;
}
var de = F();
function j(e) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}.${J()}_${de}`;
  throw new Error(`Unknown auth type: ${e}`);
}
function V(e, n = z, o) {
  const a = async (t, r) => {
    const i = await fetch(n + (t != null && t.startsWith("/") ? t : `/${t}`), {
      ...r,
      headers: {
        ...r == null ? void 0 : r.headers,
        Authorization: j(e),
        "Content-Type": "application/json"
      }
    });
    if (!i.ok) {
      let s = await i.text().catch(() => "Failed to fetch");
      throw o && o(new Error(s), {
        url: t,
        options: r,
        headers: i.headers
      }), new Error(s);
    }
    return i.json();
  };
  return {
    get(t, r) {
      return a(t, {
        ...r,
        method: "GET"
      });
    },
    post(t, r, i) {
      return a(t, {
        ...i,
        body: JSON.stringify(r),
        method: "POST"
      });
    },
    delete(t, r, i) {
      return a(t, {
        ...i,
        body: JSON.stringify(r),
        method: "DELETE"
      });
    },
    patch(t, r, i) {
      return a(t, {
        ...i,
        body: JSON.stringify(r),
        method: "PATCH"
      });
    }
  };
}
function X(e, n = z, o) {
  const a = V(e, `${n}/agents`, o);
  return {
    create(t, r) {
      return a.post("/", t, r);
    },
    getAgents(t, r) {
      return a.get(`/${t ? `?tag=${t}` : ""}`, r).then((i) => i ?? []);
    },
    getById(t, r) {
      return a.get(`/${t}`, r);
    },
    delete(t, r) {
      return a.delete(`/${t}`, void 0, r);
    },
    update(t, r, i) {
      return a.patch(`/${t}`, r, i);
    },
    newChat(t, r) {
      return a.post(`/${t}/chat`, void 0, r);
    },
    chat(t, r, i, s) {
      return a.post(`/${t}/chat/${r}`, i, s);
    },
    createRating(t, r, i, s) {
      return a.post(`/${t}/chat/${r}/ratings`, i, s);
    },
    updateRating(t, r, i, s, m) {
      return a.patch(`/${t}/chat/${r}/ratings/${i}`, s, m);
    },
    deleteRating(t, r, i, s) {
      return a.delete(`/${t}/chat/${r}/ratings/${i}`, s);
    }
  };
}
var le = (e) => new Promise((n) => setTimeout(n, e));
function me(e) {
  return new Promise((n, o) => {
    const {
      callbacks: a,
      host: t,
      auth: r
    } = e, {
      onMessage: i = null,
      onOpen: s = null,
      onClose: m = null,
      onError: d = null
    } = a || {}, l = new WebSocket(`${t}?authorization=${j(r)}`);
    l.onmessage = i, l.onclose = m, l.onerror = (v) => {
      console.error(v), d == null || d("Websocket failed to connect", v), o(v);
    }, l.onopen = (v) => {
      s == null || s(v), n(l);
    };
  });
}
async function ge(e) {
  const {
    retries: n = 1
  } = e;
  let o = null;
  for (let a = 0; (o == null ? void 0 : o.readyState) !== WebSocket.OPEN; a++)
    try {
      o = await me(e);
    } catch (t) {
      if (a === n)
        throw t;
      await le(a * 500);
    }
  return o;
}
async function ue(e, n, o) {
  const a = o != null && o.onMessage ? [o.onMessage] : [], t = await ge({
    auth: e,
    host: n,
    callbacks: {
      onError: o == null ? void 0 : o.onError,
      onMessage: (r) => {
        const i = JSON.parse(r.data);
        a.forEach((s) => s(i.event, i));
      }
    }
  });
  return {
    socket: t,
    disconnect: () => t.close(),
    subscribeToEvents: (r) => a.push(r)
  };
}
var we = "X-Playground-Chat";
function he(e, n, o, a) {
  const t = V(e, `${n}/agents/${o}`, a);
  return {
    createStream(r) {
      return t.post("/streams", {
        compatibility_mode: r.compatibility_mode,
        stream_warmup: r.stream_warmup,
        session_timeout: r.session_timeout
      });
    },
    startConnection(r, i, s) {
      return t.post(`/streams/${r}/sdp`, {
        session_id: s,
        answer: i
      });
    },
    addIceCandidate(r, i, s) {
      return t.post(`/streams/${r}/ice`, {
        session_id: s,
        ...i
      });
    },
    sendStreamRequest(r, i, s) {
      return t.post(`/streams/${r}`, {
        session_id: i,
        ...s
      });
    },
    close(r, i) {
      return t.delete(`/streams/${r}`, {
        session_id: i
      });
    }
  };
}
function fe(e, n, o, a) {
  const t = V(e, `${n}/agents/${o}`, a);
  return {
    createStream(r, i) {
      return t.post("/streams", {
        driver_url: r.driver_url,
        face: r.face,
        config: r.config,
        compatibility_mode: r.compatibility_mode,
        stream_warmup: r.stream_warmup,
        output_resolution: r.output_resolution,
        session_timeout: r.session_timeout
      }, i);
    },
    startConnection(r, i, s, m) {
      return t.post(`/streams/${r}/sdp`, {
        session_id: s,
        answer: i
      }, m);
    },
    addIceCandidate(r, i, s, m) {
      return t.post(`/streams/${r}/ice`, {
        session_id: s,
        ...i
      }, m);
    },
    sendStreamRequest(r, i, s, m) {
      return t.post(`/streams/${r}`, {
        session_id: i,
        ...s
      }, m);
    },
    close(r, i, s) {
      return t.delete(`/streams/${r}`, {
        session_id: i
      }, s);
    }
  };
}
var Y = false;
var A = (e, n) => Y && console.log(e, n);
var pe = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function H(e) {
  switch (e) {
    case "connected":
      return y.Connected;
    case "checking":
      return y.Connecting;
    case "failed":
      return y.Fail;
    case "new":
      return y.New;
    case "closed":
      return y.Closed;
    case "disconnected":
      return y.Disconnected;
    case "completed":
      return y.Completed;
    default:
      return y.New;
  }
}
function ve() {
  let e = 0;
  return (n) => {
    for (const o of n.values())
      if (o && o.type === "inbound-rtp" && o.kind === "video") {
        const a = o.bytesReceived, t = a - e > 0;
        return e = a, t;
      }
    return false;
  };
}
function ye(e, n) {
  const a = Math.max(Math.ceil(10), 1);
  let t = 0, r = false;
  const i = ve();
  return setInterval(async () => {
    const s = await e.getStats();
    i(s) ? (t = 0, r || (n == null || n(x.Start), r = true)) : r && (t++, t >= a && (n == null || n(x.Stop), r = false));
  }, 100);
}
async function Ce(e, n, {
  debug: o = false,
  callbacks: a,
  auth: t,
  baseURL: r = z,
  warmup: i
}) {
  Y = o;
  let s;
  const {
    startConnection: m,
    sendStreamRequest: d,
    close: l,
    createStream: v,
    addIceCandidate: E
  } = n.videoType === L.Clip ? he(t, r, e, a.onError) : fe(t, r, e, a.onError), {
    id: M,
    offer: O,
    ice_servers: K,
    session_id: I
  } = await v(n), p = new pe({
    iceServers: K
  }), c = p.createDataChannel("JanusDataChannel");
  if (!I)
    throw new Error("Could not create session_id");
  const w = ye(p, a.onVideoStateChange);
  p.onicecandidate = (g) => {
    A("peerConnection.onicecandidate", g), g.candidate && g.candidate.sdpMid && g.candidate.sdpMLineIndex !== null ? E(M, {
      candidate: g.candidate.candidate,
      sdpMid: g.candidate.sdpMid,
      sdpMLineIndex: g.candidate.sdpMLineIndex
    }, I) : E(M, {
      candidate: null
    }, I);
  }, p.oniceconnectionstatechange = () => {
    var u;
    A("peerConnection.oniceconnectionstatechange => " + p.iceConnectionState);
    const g = H(p.iceConnectionState);
    g === y.Connected ? s = setTimeout(() => {
      var f;
      return (f = a.onConnectionStateChange) == null ? void 0 : f.call(a, y.Connected);
    }, i ? 5e3 : 0) : (clearTimeout(s), (u = a.onConnectionStateChange) == null || u.call(a, g));
  }, p.ontrack = (g) => {
    var u;
    A("peerConnection.ontrack", g), (u = a.onSrcObjectReady) == null || u.call(a, g.streams[0]);
  }, c.onmessage = (g) => {
    var u;
    if (c.readyState === "open") {
      const [f, C] = g.data.split(":");
      f === U.StreamReady && (clearTimeout(s), (u = a.onConnectionStateChange) == null || u.call(a, y.Connected));
    }
  }, await p.setRemoteDescription(O), A("set remote description OK");
  const h = await p.createAnswer();
  return A("create answer OK"), await p.setLocalDescription(h), A("set local description OK"), await m(M, h, I), A("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(g) {
      return d(M, I, g);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var g, u;
      if (M) {
        const f = H(p.iceConnectionState);
        if (p) {
          if (f === y.New) {
            (g = a.onVideoStateChange) == null || g.call(a, x.Stop), clearInterval(w);
            return;
          }
          p.close(), p.oniceconnectionstatechange = null, p.onnegotiationneeded = null, p.onicecandidate = null, p.ontrack = null;
        }
        try {
          f === y.Connected && await l(M, I).catch((C) => {
          });
        } catch (C) {
          A("Error on close stream connection", C);
        }
        (u = a.onVideoStateChange) == null || u.call(a, x.Stop), clearInterval(w);
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: I,
    /**
     * Id of current RTC stream
     */
    streamId: M
  };
}
var W = {};
function Se(e) {
  const n = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk", o = {
    token: e.token || "testKey",
    distinct_id: e.distinctId || J(),
    agentId: e.agent.id,
    agentType: e.agent.presenter.type,
    owner_id: e.agent.owner_id ?? ""
  };
  return {
    ...o,
    isEnabled: e.isEnabled ?? true,
    getRandom: () => Math.random().toString(16).slice(2),
    track(a, t) {
      if (!this.isEnabled)
        return Promise.reject("MixPanel analytics is disabled on creation");
      const {
        audioPath: r,
        ...i
      } = t || {}, s = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([{
            event: a,
            properties: {
              ...i,
              ...o,
              source: n,
              time: Date.now(),
              $insert_id: this.getRandom(),
              origin: window.location.href,
              "Screen Height": window.screen.height || window.innerWidth,
              "Screen Width": window.screen.width || window.innerHeight,
              "User Agent": navigator.userAgent
            }
          }])
        })
      };
      return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", s).then((m) => m.json()).catch((m) => console.error(m));
    },
    linkTrack(a, t, r, i) {
      W[a] || (W[a] = {
        events: {},
        resolvedDependencies: []
      }), i.includes(r) || i.push(r);
      const s = W[a];
      if (s.events[r] = {
        props: t
      }, s.resolvedDependencies.push(r), i.every((d) => s.resolvedDependencies.includes(d))) {
        const d = i.reduce((l, v) => s.events[v] ? {
          ...l,
          ...s.events[v].props
        } : l, {});
        this.track(a, d), s.resolvedDependencies = s.resolvedDependencies.filter((l) => !i.includes(l)), i.forEach((l) => {
          delete s.events[l];
        });
      }
    }
  };
}
function Me(e) {
  var a, t, r, i, s;
  const n = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop";
  return {
    $os: `${(() => {
      const m = navigator.platform;
      return m.toLowerCase().includes("win") ? "Windows" : m.toLowerCase().includes("mac") ? "Mac OS X" : m.toLowerCase().includes("linux") ? "Linux" : "Unknown";
    })()}`,
    isMobile: `${n() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: (a = e.presenter) == null ? void 0 : a.type,
    agentVoice: {
      voiceId: (r = (t = e.presenter) == null ? void 0 : t.voice) == null ? void 0 : r.voice_id,
      provider: (s = (i = e.presenter) == null ? void 0 : i.voice) == null ? void 0 : s.type
    }
  };
}
function _e(e, n, o) {
  var d, l;
  const {
    event: a,
    ...t
  } = e, {
    template: r
  } = (n == null ? void 0 : n.llm) || {}, {
    language: i
  } = ((d = n == null ? void 0 : n.presenter) == null ? void 0 : d.voice) || {}, {
    stitch: s
  } = (n == null ? void 0 : n.presenter) || {};
  return {
    ...t,
    llm: {
      ...t.llm,
      template: r
    },
    script: {
      ...t.script,
      provider: {
        ...(l = t == null ? void 0 : t.script) == null ? void 0 : l.provider,
        language: i
      }
    },
    stitch: s,
    ...o
  };
}
var P = 0;
function ke(e, n) {
  var o, a, t, r, i, s, m;
  return e.presenter.type === L.Clip ? {
    videoType: L.Clip,
    session_timeout: (o = n == null ? void 0 : n.streamOptions) == null ? void 0 : o.sessionTimeout,
    stream_warmup: (a = n == null ? void 0 : n.streamOptions) == null ? void 0 : a.streamWarmup,
    compatibility_mode: (t = n == null ? void 0 : n.streamOptions) == null ? void 0 : t.compatibilityMode
  } : {
    videoType: L.Talk,
    session_timeout: (r = n == null ? void 0 : n.streamOptions) == null ? void 0 : r.sessionTimeout,
    stream_warmup: (i = n == null ? void 0 : n.streamOptions) == null ? void 0 : i.streamWarmup,
    compatibility_mode: (s = n == null ? void 0 : n.streamOptions) == null ? void 0 : s.compatibilityMode,
    output_resolution: (m = n == null ? void 0 : n.streamOptions) == null ? void 0 : m.outputResolution
  };
}
function Z(e) {
  return e === _.Playground ? {
    headers: {
      [we]: "true"
    }
  } : {};
}
async function Q(e, n, o, a) {
  try {
    const t = await n.newChat(e, Z(a));
    return o.track("agent-chat", {
      event: "created",
      chat_id: t.id,
      agent_id: e,
      mode: a
    }), t;
  } catch (t) {
    try {
      console.error(t);
      const r = JSON.parse(t.message);
      if ((r == null ? void 0 : r.kind) === "InsufficientCreditsError")
        throw new Error("InsufficientCreditsError");
    } catch (r) {
      console.error("Error parsing the error message:", r);
    }
    throw new Error("Cannot create new chat");
  }
}
function Ie(e, n, o, a, t) {
  return new Promise(async (r, i) => {
    var m;
    P = 0;
    const s = await Ce(e.id, ke(e, n), {
      ...n,
      analytics: a,
      warmup: (m = n.streamOptions) == null ? void 0 : m.streamWarmup,
      callbacks: {
        ...n.callbacks,
        onConnectionStateChange: async (d) => {
          var l, v;
          d === y.Connected && (!t && n.mode !== _.DirectPlayback && (t = await Q(e.id, o, a, n.mode).catch((E) => {
            i(E);
          })), s ? r({
            chat: t,
            streamingManager: s
          }) : t && i(new Error("Something went wrong while initializing the manager"))), (v = (l = n.callbacks).onConnectionStateChange) == null || v.call(l, d);
        },
        onVideoStateChange(d) {
          var l, v;
          (v = (l = n.callbacks).onVideoStateChange) == null || v.call(l, d), P > 0 && d === x.Start && a.linkTrack("agent-video", {
            event: "start",
            latency: Date.now() - P
          }, "start", [U.StreamVideoCreated]);
        }
      }
    }).catch(i);
  });
}
function q(e) {
  let n = "";
  if (e.greetings && e.greetings.length > 0) {
    const o = Math.floor(Math.random() * e.greetings.length);
    n = e.greetings[o];
  } else
    n = `Hi! I'm ${e.preview_name || "My Agent"}. How can I help you?`;
  return [{
    content: n,
    id: F(),
    role: "assistant",
    created_at: (/* @__PURE__ */ new Date()).toISOString()
  }];
}
function Re(e) {
  if (e.answer !== void 0)
    return e.answer;
  let n = 0, o = "";
  for (; n in e; )
    o += e[n], n++;
  return o;
}
function Ee(e, n, o, a, t) {
  if (!(e === b.Partial || e === b.Answer))
    return;
  const r = a.messages[a.messages.length - 1];
  if ((r == null ? void 0 : r.role) !== "assistant")
    return;
  const {
    content: i,
    sequence: s
  } = n;
  e === b.Partial ? o[s] = i : o.answer = i;
  const m = Re(o);
  (r.content !== m || e === b.Answer) && (r.content = m, t == null || t([...a.messages], e));
}
async function Ae(e, n) {
  var K, I, p;
  let o = {}, a = true;
  const t = {
    messages: [],
    chatMode: n.mode || _.Functional
  }, r = n.baseURL || z, i = n.wsURL || oe, s = n.mixpanelKey || ce, m = X(n.auth, r, n.callbacks.onError), d = await m.getById(e);
  t.messages = q(d), (I = (K = n.callbacks).onNewMessage) == null || I.call(K, [...t.messages], "answer");
  const l = Se({
    token: s,
    agent: d,
    ...n
  });
  l.track("agent-sdk", {
    event: "loaded",
    ...Me(d)
  });
  const v = {
    onMessage: (c, w) => {
      var h, g;
      if ("content" in w)
        Ee(c, w, o, t, n.callbacks.onNewMessage), c === b.Answer && l.track("agent-message-received", {
          messages: t.messages.length,
          mode: t.chatMode
        });
      else {
        const u = U, f = [u.StreamVideoDone, u.StreamVideoError, u.StreamVideoRejected], C = [u.StreamFailed, u.StreamVideoError, u.StreamVideoRejected], k = _e(w, d, {
          mode: t.chatMode
        });
        if (c = c, c === u.StreamVideoCreated)
          l.linkTrack("agent-video", k, u.StreamVideoCreated, ["start"]);
        else if (f.includes(c)) {
          const S = c.split("/")[1];
          l.track("agent-video", {
            ...k,
            event: S
          });
        }
        C.includes(c) && ((g = (h = n.callbacks).onError) == null || g.call(h, new Error(`Stream failed with event ${c}`), {
          data: w
        })), w.event === u.StreamDone && M();
      }
    }
  };
  async function E(c) {
    var C, k, S, R, T;
    P = 0, c && !a && (delete t.chat, t.messages = q(d), (k = (C = n.callbacks).onNewMessage) == null || k.call(C, [...t.messages], "answer"));
    const w = n.mode === _.DirectPlayback ? Promise.resolve(void 0) : ue(n.auth, i, v), h = Ie(d, n, m, l, t.chat).catch(($) => {
      throw O(_.Maintenance), $;
    }), [g, {
      streamingManager: u,
      chat: f
    }] = await Promise.all([w, h]);
    f && f.id !== ((S = t.chat) == null ? void 0 : S.id) && ((T = (R = n.callbacks).onNewChat) == null || T.call(R, f.id)), t.streamingManager = u, t.socketManager = g, t.chat = f, a = false, O((f == null ? void 0 : f.chat_mode) ?? n.mode ?? _.Functional);
  }
  async function M() {
    var c, w, h, g;
    (c = t.socketManager) == null || c.disconnect(), await ((w = t.streamingManager) == null ? void 0 : w.disconnect()), delete t.streamingManager, delete t.socketManager, (g = (h = n.callbacks).onConnectionStateChange) == null || g.call(h, y.Disconnected);
  }
  async function O(c) {
    var w, h;
    c !== t.chatMode && (l.track("agent-mode-change", {
      mode: c
    }), t.chatMode = c, t.chatMode !== _.Functional && await M(), (h = (w = n.callbacks).onModeChange) == null || h.call(w, c));
  }
  return {
    agent: d,
    starterMessages: ((p = d.knowledge) == null ? void 0 : p.starter_message) || [],
    changeMode: O,
    async connect() {
      var c;
      await E(true), l.track("agent-chat", {
        event: "connect",
        chatId: (c = t.chat) == null ? void 0 : c.id,
        agentId: d.id,
        mode: t.chatMode
      });
    },
    async reconnect() {
      var c;
      await M(), await E(false), l.track("agent-chat", {
        event: "reconnect",
        chatId: (c = t.chat) == null ? void 0 : c.id,
        agentId: d.id,
        mode: t.chatMode
      });
    },
    async disconnect() {
      var c;
      await M(), l.track("agent-chat", {
        event: "disconnect",
        chatId: (c = t.chat) == null ? void 0 : c.id,
        agentId: d.id,
        mode: t.chatMode
      });
    },
    async chat(c) {
      var h, g, u, f, C, k;
      const w = F();
      o = {};
      try {
        if (P = Date.now(), n.mode === _.DirectPlayback)
          throw new Error("Direct playback is enabled, chat is disabled");
        if (c.length >= 800)
          throw new Error("Message cannot be more than 800 characters");
        if (c.length === 0)
          throw new Error("Message cannot be empty");
        if (t.chatMode === _.Maintenance)
          throw new Error("Chat is in maintenance mode");
        if (![_.TextOnly, _.Playground].includes(t.chatMode))
          if (t.streamingManager) {
            if (!t.chat)
              throw new Error("Chat is not initialized");
          } else
            throw new Error("Streaming manager is not initialized");
        t.messages.push({
          id: F(),
          role: "user",
          content: c,
          created_at: new Date(P).toISOString()
        }), (g = (h = n.callbacks).onNewMessage) == null || g.call(h, [...t.messages], "user"), t.chat || (t.chat = await Q(d.id, m, l, t.chatMode), (f = (u = n.callbacks).onNewChat) == null || f.call(u, t.chat.id));
        const S = {
          id: w,
          role: "assistant",
          content: "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          matches: []
        }, R = [...t.messages];
        t.messages.push(S);
        const T = (D) => {
          var N, B;
          return m.chat(d.id, D, {
            sessionId: (N = t.streamingManager) == null ? void 0 : N.sessionId,
            streamId: (B = t.streamingManager) == null ? void 0 : B.streamId,
            chatMode: t.chatMode,
            messages: R
          }, Z(t.chatMode));
        }, $ = await T(t.chat.id).catch(async (D) => {
          var N;
          if (!((N = D == null ? void 0 : D.message) != null && N.includes("missing or invalid session_id")))
            throw D;
          return await M(), await E(false), T(t.chat.id);
        });
        return l.track("agent-message-send", {
          event: "success",
          mode: t.chatMode,
          messages: t.messages.length + 1
        }), S.context = $.context, S.matches = $.matches, $.result && (S.content = $.result, l.track("agent-message-received", {
          latency: Date.now() - P,
          mode: t.chatMode,
          messages: t.messages.length
        }), (k = (C = n.callbacks).onNewMessage) == null || k.call(C, [...t.messages], "answer")), $;
      } catch (S) {
        throw t.messages[t.messages.length - 1].id === w && t.messages.pop(), l.track("agent-message-send", {
          event: "error",
          mode: t.chatMode,
          messages: t.messages.length
        }), S;
      }
    },
    rate(c, w, h) {
      var f, C, k, S;
      const g = t.messages.find((R) => R.id === c);
      if (t.chat) {
        if (!g)
          throw new Error("Message not found");
      } else
        throw new Error("Chat is not initialized");
      const u = ((f = g.matches) == null ? void 0 : f.map((R) => [R.document_id, R.id])) ?? [];
      return l.track("agent-rate", {
        event: h ? "update" : "create",
        thumb: w === 1 ? "up" : "down",
        knowledge_id: ((C = d.knowledge) == null ? void 0 : C.id) ?? "",
        mode: t.chatMode,
        matches: u,
        score: w
      }), h ? m.updateRating(d.id, t.chat.id, h, {
        knowledge_id: ((k = d.knowledge) == null ? void 0 : k.id) ?? "",
        message_id: c,
        matches: u,
        score: w
      }) : m.createRating(d.id, t.chat.id, {
        knowledge_id: ((S = d.knowledge) == null ? void 0 : S.id) ?? "",
        message_id: c,
        matches: u,
        score: w
      });
    },
    deleteRate(c) {
      var w;
      if (!t.chat)
        throw new Error("Chat is not initialized");
      return l.track("agent-rate-delete", {
        type: "text",
        chat_id: (w = t.chat) == null ? void 0 : w.id,
        id: c,
        mode: t.chatMode
      }), m.deleteRating(d.id, t.chat.id, c);
    },
    speak(c) {
      if (!t.streamingManager)
        throw new Error("Please connect to the agent first");
      function w() {
        if (typeof c == "string") {
          if (!d.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: d.presenter.voice,
            input: c,
            ssml: false
          };
        }
        if (c.type === "text" && !c.provider) {
          if (!d.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: d.presenter.voice,
            input: c.input,
            ssml: c.ssml
          };
        }
        return c;
      }
      const h = w();
      return l.track("agent-speak", h), t.streamingManager.speak({
        script: h
      });
    }
  };
}
function $e(e, n, o) {
  const {
    getById: a
  } = X(n, o || z);
  return a(e);
}
export {
  _ as ChatMode,
  b as ChatProgress,
  y as ConnectionState,
  ae as DocumentType,
  re as KnowledgeType,
  ee as PlanGroup,
  ie as Providers,
  te as RateState,
  U as StreamEvents,
  x as StreamingState,
  ne as Subject,
  G as UserPlan,
  L as VideoType,
  se as VoiceAccess,
  Ae as createAgentManager,
  $e as getAgent
};
//# sourceMappingURL=@d-id_client-sdk.js.map
